<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hardest Game</title>
    <style>
        body { margin: 0; }
        canvas { display: block; }
    </style>
</head>
<body>
    <script>
        // Game variables
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        const WIDTH = 800;
        const HEIGHT = 600;
        const DOT_SIZE = 20;
        const OBSTACLE_SIZE = 30;
        const OBSTACLE_SPEED = 3;
        let dotX = WIDTH / 2;
        let dotY = HEIGHT / 2;
        let obstacles = [];
        let score = 0;
        let gameOver = false;

        canvas.width = WIDTH;
        canvas.height = HEIGHT;
        document.body.appendChild(canvas);

        // Event listeners for controls
        document.addEventListener('keydown', (event) => {
            if (event.code === 'ArrowUp') dotY -= 10;
            if (event.code === 'ArrowDown') dotY += 10;
            if (event.code === 'ArrowLeft') dotX -= 10;
            if (event.code === 'ArrowRight') dotX += 10;
        });

        // Function to generate obstacles
        function generateObstacle() {
            const x = Math.random() * (WIDTH - OBSTACLE_SIZE);
            obstacles.push({ x, y: -OBSTACLE_SIZE });
        }

        // Function to update game state
        function update() {
            if (gameOver) return;

            // Move obstacles
            obstacles.forEach(obstacle => {
                obstacle.y += OBSTACLE_SPEED;
            });

            // Remove off-screen obstacles
            obstacles = obstacles.filter(obstacle => obstacle.y < HEIGHT);

            // Check collision
            obstacles.forEach(obstacle => {
                if (
                    dotX < obstacle.x + OBSTACLE_SIZE &&
                    dotX + DOT_SIZE > obstacle.x &&
                    dotY < obstacle.y + OBSTACLE_SIZE &&
                    dotY + DOT_SIZE > obstacle.y
                ) {
                    gameOver = true;
                }
            });

            // Increase score
            score++;
            if (score % 100 === 0) {
                generateObstacle();
            }
        }

        // Function to draw everything
        function draw() {
            ctx.clearRect(0, 0, WIDTH, HEIGHT);

            // Draw dot
            ctx.fillStyle = 'blue';
            ctx.fillRect(dotX, dotY, DOT_SIZE, DOT_SIZE);

            // Draw obstacles
            ctx.fillStyle = 'red';
            obstacles.forEach(obstacle => {
                ctx.fillRect(obstacle.x, obstacle.y, OBSTACLE_SIZE, OBSTACLE_SIZE);
            });

            // Draw score
            ctx.fillStyle = 'black';
            ctx.font = '24px Arial';
            ctx.fillText('Score: ' + score, 10, 30);

            // Draw game over message
            if (gameOver) {
                ctx.fillStyle = 'black';
                ctx.font = '48px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('Game Over', WIDTH / 2, HEIGHT / 2);
            }
        }

        // Main game loop
        function gameLoop() {
            if (gameOver) return;
            update();
            draw();
            requestAnimationFrame(gameLoop);
        }

        // Start the game
        generateObstacle(); // Initial obstacle
        gameLoop();
    </script>
</body>
</html>
